From f68b858073e7c16236430ee349fb565ac18cf3d4 Mon Sep 17 00:00:00 2001
From: Mike Perry <mikeperry-git@fscked.org>
Date: Sat, 3 Sep 2011 00:10:35 -0700
Subject: [PATCH 6/8] Randomize HTTP pipeline order and depth.

Also turn up maximum depth to 12.

This is an experimental defense against
http://lorre.uni.lu/~andriy/papers/acmccs-wpes11-fingerprinting.pdf
---
 netwerk/protocol/http/nsHttpConnectionMgr.cpp |   78 ++++++++++++++++++++++++-
 netwerk/protocol/http/nsHttpConnectionMgr.h   |    4 +
 2 files changed, 81 insertions(+), 1 deletions(-)

diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
index c754f83..6a522ec 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -93,6 +93,11 @@ nsHttpConnectionMgr::nsHttpConnectionMgr()
     , mTimeOfNextWakeUp(LL_MAXUINT)
 {
     LOG(("Creating nsHttpConnectionMgr @%x\n", this));
+    nsresult rv;
+    mRandomGenerator = do_GetService("@mozilla.org/security/random-generator;1", &rv);
+    if (NS_FAILED(rv)) {
+        mRandomGenerator = nsnull;
+    }
 }
 
 nsHttpConnectionMgr::~nsHttpConnectionMgr()
@@ -822,7 +827,7 @@ nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
     nsHttpPipeline *pipeline = nsnull;
     if (conn->SupportsPipelining() && (caps & NS_HTTP_ALLOW_PIPELINING)) {
         LOG(("  looking to build pipeline...\n"));
-        if (BuildPipeline(ent, trans, &pipeline))
+        if (BuildRandomizedPipeline(ent, trans, &pipeline))
             trans = pipeline;
     }
 
@@ -895,6 +900,77 @@ nsHttpConnectionMgr::BuildPipeline(nsConnectionEntry *ent,
     return PR_TRUE;
 }
 
+PRBool
+nsHttpConnectionMgr::BuildRandomizedPipeline(nsConnectionEntry *ent,
+                                   nsAHttpTransaction *firstTrans,
+                                   nsHttpPipeline **result)
+{
+    if (mRandomGenerator == nsnull)
+        return BuildPipeline(ent, firstTrans, result);
+    if (mMaxPipelinedRequests < 2)
+        return PR_FALSE;
+
+    nsresult rv;
+    PRUint8 *bytes = nsnull;
+
+    nsHttpPipeline *pipeline = nsnull;
+    nsHttpTransaction *trans;
+
+    PRUint32 i = 0, numAdded = 0, numAllowed = 0;
+    PRUint32 max = 0;
+
+    while (i < ent->mPendingQ.Length()) {
+        if (ent->mPendingQ[i]->Caps() & NS_HTTP_ALLOW_PIPELINING)
+            numAllowed++;
+        i++;
+    }
+
+    rv = mRandomGenerator->GenerateRandomBytes(1, &bytes);
+    NS_ENSURE_SUCCESS(rv, rv);
+    // 4...12
+    max = 4 + (bytes[0] % (mMaxPipelinedRequests + 1));
+    NS_Free(bytes);
+
+    while (numAllowed > 0) {
+        rv = mRandomGenerator->GenerateRandomBytes(1, &bytes);
+        NS_ENSURE_SUCCESS(rv, rv);
+        i = bytes[0] % ent->mPendingQ.Length();
+        NS_Free(bytes);
+
+        trans = ent->mPendingQ[i];
+
+        if (!(ent->mPendingQ[i]->Caps() & NS_HTTP_ALLOW_PIPELINING))
+            continue;
+
+        if (numAdded == 0) {
+            pipeline = new nsHttpPipeline;
+            if (!pipeline)
+                return PR_FALSE;
+            pipeline->AddTransaction(firstTrans);
+            numAdded = 1;
+        }
+        pipeline->AddTransaction(trans);
+
+        // remove transaction from pending queue
+        ent->mPendingQ.RemoveElementAt(i);
+        NS_RELEASE(trans);
+
+        numAllowed--;
+
+        if (++numAdded == max)
+            break;
+    }
+
+    //fprintf(stderr, "Yay!!! pipelined %u/%u transactions\n", numAdded, max);
+    LOG(("  pipelined %u/%u transactions\n", numAdded, max));
+
+    if (numAdded == 0)
+        return PR_FALSE;
+
+    NS_ADDREF(*result = pipeline);
+    return PR_TRUE;
+}
+
 nsresult
 nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans)
 {
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
index 695cd8f..1806d17 100644
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -48,6 +48,7 @@
 #include "nsAutoPtr.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "nsISocketTransportService.h"
+#include "nsIRandomGenerator.h"
 
 #include "nsIObserver.h"
 #include "nsITimer.h"
@@ -270,6 +271,7 @@ private:
     nsresult DispatchTransaction(nsConnectionEntry *, nsAHttpTransaction *,
                                  PRUint8 caps, nsHttpConnection *);
     PRBool   BuildPipeline(nsConnectionEntry *, nsAHttpTransaction *, nsHttpPipeline **);
+    PRBool   BuildRandomizedPipeline(nsConnectionEntry *, nsAHttpTransaction *, nsHttpPipeline **);
     nsresult ProcessNewTransaction(nsHttpTransaction *);
     nsresult EnsureSocketThreadTargetIfOnline();
     nsresult CreateTransport(nsConnectionEntry *, nsHttpTransaction *);
@@ -345,6 +347,8 @@ private:
     PRUint64 mTimeOfNextWakeUp;
     // Timer for next pruning of dead connections.
     nsCOMPtr<nsITimer> mTimer;
+    // Random number generator for reordering HTTP pipeline
+    nsCOMPtr<nsIRandomGenerator>             mRandomGenerator;
 
     //
     // the connection table
-- 
1.7.3.4

